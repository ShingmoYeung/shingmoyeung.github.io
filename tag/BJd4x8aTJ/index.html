<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    2019-09 | 代码人生
</title>
<link rel="shortcut icon" href="https://shingmoyeung.coding.me/favicon.ico?v=1569673038247">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://shingmoyeung.coding.me/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://shingmoyeung.coding.me/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://shingmoyeung.coding.me">
                <img class="avatar" src="https://shingmoyeung.coding.me/images/avatar.png?v=1569673038247" alt="">
            </a>
            <div class="site-title">
                <h1>
                    代码人生
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        2019-09</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://shingmoyeung.coding.me/post/macos-kai-qi-lan-ya-yin-xiao-diao-zheng">
                        MacOS 开启蓝牙音效调整
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-09-27 22:21</time>
                    
                        <a href="https://shingmoyeung.coding.me/tag/macos" class="post-tag i-tag
                            i-tag-info">
            #MacOS
        </a>
                        
                        <a href="https://shingmoyeung.coding.me/tag/apple" class="post-tag i-tag
                            i-tag-warning">
            #Apple
        </a>
                        
                        <a href="https://shingmoyeung.coding.me/tag/BJd4x8aTJ" class="post-tag i-tag
                            i-tag-other_2">
            #2019-09
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://shingmoyeung.coding.me/post/macos-kai-qi-lan-ya-yin-xiao-diao-zheng" class="post-feature-image" style="background-image:url(https://shingmoyeung.coding.me/post-images/macos-kai-qi-lan-ya-yin-xiao-diao-zheng.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            ACC 和 AptX 的启用也可以通过命令行的命令
sudo defaults write bluetoothaudiod &amp;quot;Enable AptX codec&amp;quot; -bool true
sudo defaults write bluetoothaudiod &amp;quot;Enable AAC codec&amp;quot; -bool true

AirPods 连 Mac 卡的，执行上面命令，然后重启
defaults write com.apple.BluetoothAudioAgent &amp;quot;Apple Bitpool Max (editable)&amp;quot; 80 
defaults write com.apple.BluetoothAudioAgent &amp;quot;Apple Bitpool Min (editable)&amp;quot; 80 
defaults write com.apple.BluetoothAudioAgent &amp;quot;Apple Initial Bitpool (editable)&amp;quot; 80 
defaults write com.apple.BluetoothAudioAgent &amp;quot;Apple Initial Bitpool Min (editable)&amp;quot; 80 
defaults write com.apple.BluetoothAudioAgent &amp;quot;Negotiated Bitpool&amp;quot; 80 
defaults write com.apple.BluetoothAudioAgent &amp;quot;Negotiated Bitpool Max&amp;quot; 80 
defaults write com.apple.BluetoothAudioAgent &amp;quot;Negotiated Bitpool Min&amp;quot; 80


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://shingmoyeung.coding.me/post/macos-kai-qi-lan-ya-yin-xiao-diao-zheng">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://shingmoyeung.coding.me/post/jmeter-can-shu-hua-shi-xian">
                        JMeter 参数化实现
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-09-19 19:49</time>
                    
                        <a href="https://shingmoyeung.coding.me/tag/ce-shi-na-xie-shi-er" class="post-tag i-tag
                            i-tag-info">
            #测试那些事儿
        </a>
                        
                        <a href="https://shingmoyeung.coding.me/tag/BJd4x8aTJ" class="post-tag i-tag
                            i-tag-other_2">
            #2019-09
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            在测试过程中，我们经常遇到需要根据需求动态操作数据的情况，常规的固定数据无法满足我们的需要，这个时候，我们可以通过jmeter 提供的参数化组件来实现动态的获取数据、改变数据。
Jmeter 中常用的参数化方式
  JMeter 为我们提供了四种实现参数化的方式，分别是【CSV Data Set Config】（数据集配置）组件、【用户参数】组件、【用户定义的变量】组件和【函数】组件，四种方式都有各自的使用场景，互为补充。

1.【CSV Data Set Config】（数据集配置）组件
  我们借助此组件可以实现动态的从外部CSV文件中获取数据，从而达到批量操作数据的目的。

使用此组件的前提条件：我们需要有一个 CSV 格式的数据文件。
CSV文件编写格式：
1.每一行代表一条数据；
2.各字段之间用英文逗号分隔开；
3.编码格式采用 utf-8。
假设现在有一个 CSV 格式的数据文件csv_test.txt，该文件内容如下图所示：

要实现依次读取文件中的内容，并将内容中第一个字段的值作为关键字在百度中搜索的操作，我们可以这样做：
1）在jmeter中依次创建【测试计划】、【线程组】和【HTTP 请求】，并添加查看结果的组件【查看结果树】如图：

2）添加【CSV Data Set Config】（数据集配置）组件：右击【线程组】—&amp;gt;【添加】—&amp;gt;【配置元件】—&amp;gt;【CSV Data Set Config】。
3）配置参数
设置线程组循环次数：选中【线程组】，在右边属性窗口中将【循环次数】设置成 与CSV 数据文件中数据条数相同，在本例中即为3。

设置 CSV Data Set Config 组件的参数
Filename：CSV 数据文件所在路径。

File encoding：CSV文件的编码格式，即 utf-8；
Variable Names（comma-delimited）：给 CSV 数据文件中数据的每个字段取一个名字，作为调用的变量名；CSV 中每个字段都对应一个变量，每个变量用逗号隔开
Delimiter(use ‘\t’ for tab)：与CSV 中的分隔符 保持一致，本例中即为英文逗号；
一般情况下，我们只需要设置这四个属性即可。
4）使用变量
变量名即为上一步骤中设置的变量名
变量使用格式为${变量名}
在 HTTP 请求 URL 路径中使用正确格式调用变量，如图。

为了结果更明确，在 HTTP 请求的命名中也调用此变量标注。
5）执行，结果如下图：

结果中显示，我们依次从 CSV 数据文件中获取到了每条数据的第一个字段的值，并将其作为百度搜索的关键字执行了搜索。
2.【用户参数】组件
  除了读取外部文件中的数据，我们还可以在jmeter中定义一些数据，实现批量操作数据的功能。但由于此操作不是那么的易用，所以数据量较大时，不建议使用此操作。

下面我们来看一下具体是怎么操作的：
1）这里我们先把上面添加的 CSV Data Set Config 组件禁用掉（右击该组件后选择【禁用】即可）；

2）通过添加【用户参数】组件，用来配置数据：右击【测试计划】—&amp;gt;【添加】—&amp;gt;【前置处理器】—&amp;gt;【用户参数】，如图：

3）配置数据。我们可以看到用户参数面板如下图所示，主要使用的部分就是图中标注出来的三个部分：

①这里应该不陌生了，就是用来标注我们这部分的参数是给干什么用的，取个名字，见名知意，好让我们以后再看的时候不会迷糊。
②这里我们看到有四个按钮，第一行的两个是用来操作变量的，第二行的两个是用来操作用户的。这里所谓的变量就是我们要设置的参数变量名，用来在后面调用的；而用户就是参数值，每一个用户对应一条数据。
③ 点击【添加变量】后会在③中添加一行输入框，提供给我们输入变量名和变量值，输入后保存即可。点击【添加用户】后会在【用户_1】后面添加一列，表示可以多添加一条数据。
我们还是用上面例子中的数据添加到这，如下图：

从上面的结构我们可以看出，【用户参数】组件是通过表格的形式来存储数据的，每个变量和变量值都需要我们手动去一条一条添加，可想而知，如果数据量比较大的情况下，我们还是用此方式操作的话，就会比较麻烦了。这种情况下，就建议使用第一种方式来批量操作数据了。
4）更改线程组设置，让jmeter循环读取我们的数据：
将线程组的【线程数】更改为与我们【用户参数】中用户数量相同；
将线程组的【循环次数】更改回 1 次。
5）调用参数的方式与上面的例子相同，在需要的地方使用&amp;quot;${变量名}&amp;quot;的格式调用即可，这次我们来遍历一下 【country】的值。

6）我们来执行一下，看看读取【用户参数】的执行结果：

出现上面的结果，就说明我们配置成功了！
3.【用户定义的变量】组件
1）通常，在项目的接口中经常会遇到一些相同的部分，当这个相同的不出频繁出现时，我们可以将其抽取出来，作为一个全局的变量供我们调用，定义全局变量我们可以通过定义【用户定义的变量】来实现；
2）这里我们抽取 HTTP 请求的【服务器名称】和【端口号】来举例。
3）添加【用户定义的变量】组件：右击【测试计划】—&amp;gt;【添加】—&amp;gt;【配置元件】—&amp;gt;【用户定义的变量】，如图所示，

4）【用户定义的变量】面板如下图所示，我们依次来介绍。

①取个见名知意的名字
②点击【添加】，就会出现③中的输入框；点击【删除】，就会在③中删除一个变量。
③【名称】：即参数名，变量名；【值】：参数值，变量值；【Description】：对变量的描述信息，可不填。

5）调用方式和之前一样，HTTP 请求的【服务器名称】和【端口号】的位置调用这两个变量：

6）查看执行结果，如下：

这里我们要注意的是：【用户定义的变量】是全局变量，即这里定义的变量的所有值只会初始化一次，无论后面创建了多少线程，值都不会变。也正是因为这个原因，为了不占用过多资源，建议不要创建太多这种类型的变量。
4.【函数】组件
  在jmeter 中已经内置了一些【函数】供我们使用，给我们的测试工作提供了很大的便利。在jmeter中常用的【函数】主要有6个，我们通过其中的__counter()为例来介绍【函数】组件的使用方式，后面再介绍每个函数的功能。

1）调出【函数】组件有三种方式，我们在使用时选择任意一种即可：
方式一：菜单栏【选项】—&amp;gt;【函数助手对话框】

方式二：工具栏中倒数第二个类似于笔记本的按钮【函数助手对话框】

方式三：使用快捷键：
Windows 平台：Ctrl+shift+F1
Mac 平台：shift+command+F1
执行1）中的操作后，会出现下面的对话框：

①选择我们需要使用的函数__counter
②设置函数调用时需要的参数：
第一行：设置此计数器的作用范围：
TRUE：用户范围内有效，在本例中我们可以认为是单次循环内有效；
FALSE：全局范围内有效，即在多次循环范围内有效。
第二行：这里要给函数的返回值取个名字，以便后面调用，这个是选填参数；
③点击【生成】按钮，在输入框中就会出现完整的函数调用代码，我们直接复制到需要调用该函数的位置即可。

3） 为了直观体现出参数的作用，我们把线程组的【循环次数】设置为多次，这里就设置为3。
当参数选择 TRUE 时：


查看结果，我们可以发现，每次循环都是从1开始的。
当参数选择 FALSE 时：

查看结果，我们可以发现，所有循环使用同一个计数器，新循环开始时，计数器不再重置为1，而是继上次循环结束时的结果递增。
至此，函数的调用方式就介绍完了，下面就介绍一下jmeter中内置的6个常用函数：
__counter()：计数器，上面介绍过了，就不再赘述。
__random()：产生一个随机数。
参数1：随机范围的低边界值，即随机范围内的最小值；
参数2：随机范围的高边界值，即随机范围内的最大值；
如下图中的设置所示，随机范围为[0,100] ，即两个边界值都可能取到。

__time()：返回当前时间，默认为距离1970年1月1日 0时0分0秒的毫秒值。
参数1：设置返回的时间表现形式，
yyyy：表示年份
MM：表示月份
dd：表示日期
hh/HH：表示小时（hh：12小时制，HH：24小时制）；
mm：表示分钟
ss：表示秒

__CSVRead()：读取外部 CSV 格式文件，类似于 CSV Data Set Config 组件，用来批量操作数据。
参数1：CSV 文件路径，注意这里要填写 CSV 文件的绝对路径；
参数2：要读取CSV 文件中哪一个字段的值，这里填写的是字段对应的 index 值，index 从0开始计数，即第一个字段对应的 index 为0 。

注意：此函数读取 CSV 文件要注意：
此函数调用一次，只能读取一个字段的值，所以想要读出所有字段，需要多次调用此函数；
将线程组的【线程数】设置为与 CSV 文件数据行数相同，可以读出当前字段对应的所有值；
查看结果
线程数设置为3，（与 CSV 文件数据行相同）
只用一次 HTTP 请求，读取一个字段的值


结果显示，我们只读取了一个字段对应的所有数据。
下面我们再创建一个 HTTP 请求，多调用一次此函数，读取两个字段的值，注意第二各字段对应的 index 为1，不要忘记修改。

由结果看出，线程数为3，发送两次请求，调用两次此函数，成功的读取出了 CSV 文件中的两个字段对应三条数据的所有值。
__setProperty() 和 __property()：用于线程组之间传参。
__setProperty() 在线程组1中将属性及属性值放到测试计划的共享空间中；
__property()在线程组2中从共享空间中获取属性。
至此，Jmeter的参数化实现方式就介绍完了，希望以后看到的时候不会迷糊！哈哈~~

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://shingmoyeung.coding.me/post/jmeter-can-shu-hua-shi-xian">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://shingmoyeung.coding.me/post/shou-xie-redis-cacheable-zhu-jie-can-shu-java-dui-xiang-zuo-wei-key-zhi">
                        手写Redis @Cacheable注解 参数Java对象作为key值
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-09-07 20:21</time>
                    
                        <a href="https://shingmoyeung.coding.me/tag/dai-ma-na-xie-shi-er" class="post-tag i-tag
                            i-tag-other_4">
            #代码那些事儿
        </a>
                        
                        <a href="https://shingmoyeung.coding.me/tag/redis" class="post-tag i-tag
                            i-tag-warning">
            #Redis
        </a>
                        
                        <a href="https://shingmoyeung.coding.me/tag/BJd4x8aTJ" class="post-tag i-tag
                            i-tag-info">
            #2019-09
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            1.实现方式说明
本文在---- 手写redis @ Cacheable注解支持过期时间设置   的基础之上进行扩展。
1.1问题说明：
@Cacheable（key = “&#39;leader&#39;+＃p0 +＃p1 +＃p2”）一般用法，＃p0表示方法的第一个参数，＃p1表示第二个参数，以此类推。
目前方法的第一个参数为Java的对象，但是原注解只支持Java的的基本数据类型。
1.2实现步骤：
1.在原注解中加入新的参数，
objectIndexArray表示哪几个角标参数(从0开始)为java对象，objectFieldArray表示对应位置该对象的字段值作为key
2.如何获取参数的对象以及该字段的值
使用的java的反射，拼接get方法获取该字段值。
2.源代码
修改java注解@ExtCacheable，本文中使用@NewCacheable
    package com.huajie.annotation;

    import java.lang.annotation.ElementType;

    import java.lang.annotation.Retention;

    import java.lang.annotation.RetentionPolicy;

    import java.lang.annotation.Target;

    @Target({ ElementType.METHOD })
    @Retention(RetentionPolicy.RUNTIME)
    public @interface NewCacheable {

        String key() default &amp;quot;&amp;quot;;

        int[] objectIndexArray();

        String[] objectFieldArray();

        int expireTime() default 1800;//30分钟
}

SpringAop切面NewCacheableAspect
获取AOP整体流程没有任何变化
主要是关键值获取的方式，发生了变化
使用Java的反射技术
完整代码如下：
    package com.huajie.aspect;

    import com.huajie.annotation.NewCacheable;

    import com.huajie.utils.RedisUtil;

    import com.huajie.utils.StringUtil;

    import lombok.extern.slf4j.Slf4j;

    import org.aspectj.lang.ProceedingJoinPoint;

    import org.aspectj.lang.annotation.Around;

    import org.aspectj.lang.annotation.Aspect;

    import org.aspectj.lang.annotation.Pointcut;

    import org.aspectj.lang.reflect.MethodSignature;

    import org.springframework.beans.factory.annotation.Autowired;

    import org.springframework.stereotype.Component;

    import java.lang.reflect.Method;

    import java.util.ArrayList;

    import java.util.List;

    /**

     * redis缓存处理 不适用与内部方法调用(this.)或者private

    */

    @Component

    @Aspect

    @Slf4j

    public class NewCacheableAspect {

 

    @Autowired

    private RedisUtil redisUtil;

 

    @Pointcut(&amp;quot;@annotation(com.huajie.annotation.NewCacheable)&amp;quot;)

    public void annotationPointcut() {

    }

 

    @Around(&amp;quot;annotationPointcut()&amp;quot;)

    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {

    // 获得当前访问的class

    Class&amp;lt;?&amp;gt; className = joinPoint.getTarget().getClass();

    // 获得访问的方法名

    String methodName = joinPoint.getSignature().getName();

    // 得到方法的参数的类型

    Class&amp;lt;?&amp;gt;[] argClass = ((MethodSignature) joinPoint.getSignature()).getParameterTypes();

    Object[] args = joinPoint.getArgs();

    String key = &amp;quot;&amp;quot;;

    int expireTime = 3600;

    try {

    // 得到访问的方法对象

    Method method = className.getMethod(methodName, argClass);

    method.setAccessible(true);

    // 判断是否存在@ExtCacheable注解

    if (method.isAnnotationPresent(NewCacheable.class)) {

    NewCacheable annotation = method.getAnnotation(NewCacheable.class);

    key = getRedisKey(args, annotation);

    expireTime = getExpireTime(annotation);

    }

    } catch (Exception e) {

    throw new RuntimeException(&amp;quot;redis缓存注解参数异常&amp;quot;, e);

    }

    log.info(key);

    boolean hasKey = redisUtil.hasKey(key);

    if (hasKey) {

    return redisUtil.get(key);

    } else {

    Object res = joinPoint.proceed();

    redisUtil.set(key, res);

    redisUtil.expire(key, expireTime);

    return res;

    }

    }

 

    private int getExpireTime(NewCacheable annotation) {

    return annotation.expireTime();

    }

 

    private String getRedisKey(Object[] args, NewCacheable annotation) throws Exception{

    String primalKey = annotation.key();

    // 获取#p0...集合

    List&amp;lt;String&amp;gt; keyList = getKeyParsList(primalKey);

    for (String keyName : keyList) {

    int keyIndex = Integer.parseInt(keyName.toLowerCase().replace(&amp;quot;#p&amp;quot;, &amp;quot;&amp;quot;));

    Object parValue = getParValue(annotation, keyIndex, args);

    primalKey = primalKey.replace(keyName, String.valueOf(parValue));

    }

    return primalKey.replace(&amp;quot;+&amp;quot;, &amp;quot;&amp;quot;).replace(&amp;quot;&#39;&amp;quot;, &amp;quot;&amp;quot;);

    }

 

    private Object getParValue(NewCacheable annotation, int keyIndex, Object[] args) throws Exception{

    int[] objectIndexArray = annotation.objectIndexArray();

    String[] objectFieldArray = annotation.objectFieldArray();

    if (existsObject(keyIndex, objectIndexArray)) {

    return getParValueByObject(args, keyIndex, objectFieldArray);

    } else {

    return args[keyIndex];

    }

    }

 

    private Object getParValueByObject(Object[] args, int keyIndex, String[] objectFieldArray) throws Exception {

    Class cls = args[keyIndex].getClass();

    Method method;

    if(objectFieldArray!=null&amp;amp;&amp;amp;objectFieldArray.length&amp;gt;=keyIndex){

    method = cls.getMethod(&amp;quot;get&amp;quot; + StringUtil.firstCharToUpperCase(objectFieldArray[keyIndex]));

    }else{

    method = cls.getMethod(&amp;quot;get&amp;quot; + StringUtil.firstCharToUpperCase(cls.getFields()[0].getName()));

    }

    method.setAccessible(true);

    log.info(method.getName());

    return method.invoke(args[keyIndex]);

    }

 

    private boolean existsObject(int keyIndex, int[] objectIndexArray) {

    if (objectIndexArray == null || objectIndexArray.length &amp;lt;= 0) {

    return false;

    }

    for (int i = 0; i &amp;lt; objectIndexArray.length; i++) {

    if (keyIndex == objectIndexArray[i]) {

    return true;

    }

    }

    return false;

    }

 

    // 获取key中#p0中的参数名称

    private static List&amp;lt;String&amp;gt; getKeyParsList(String key) {

    List&amp;lt;String&amp;gt; ListPar = new ArrayList&amp;lt;String&amp;gt;();

    if (key.indexOf(&amp;quot;#&amp;quot;) &amp;gt;= 0) {

    int plusIndex = key.substring(key.indexOf(&amp;quot;#&amp;quot;)).indexOf(&amp;quot;+&amp;quot;);

    int indexNext = 0;

    String parName = &amp;quot;&amp;quot;;

    int indexPre = key.indexOf(&amp;quot;#&amp;quot;);

    if (plusIndex &amp;gt; 0) {

    indexNext = key.indexOf(&amp;quot;#&amp;quot;) + key.substring(key.indexOf(&amp;quot;#&amp;quot;)).indexOf(&amp;quot;+&amp;quot;);

    parName = key.substring(indexPre, indexNext);

    } else {

    parName = key.substring(indexPre);

    }

    ListPar.add(parName.trim());

    key = key.substring(indexNext + 1);

    if (key.indexOf(&amp;quot;#&amp;quot;) &amp;gt;= 0) {

    ListPar.addAll(getKeyParsList(key));

    }

    }

    return ListPar;
    }
}

3.测试
业务模块使用方法controller
    @RequestMapping(&amp;quot;queryQuotaTreeData&amp;quot;)
	@ResponseBody
	public List&amp;lt;TreeNode&amp;gt; getTreeData() {

		QuotaManage quotaManage = new QuotaManage();

		quotaManage.setQuotaName(&amp;quot;测试22222&amp;quot;);

		List&amp;lt;TreeNode&amp;gt; list  = this.quotaManageService.queryQuotaTreeData(quotaManage);

		return list;

}

实现层objectIndexArray中的{0}表示第0个参数，objectFieldArray中的“quotaName”表示对应对象中的字段名称
    @Override
	@NewCacheable(key=&amp;quot;test+#p0&amp;quot;,objectIndexArray = {0},objectFieldArray = {&amp;quot;quotaName&amp;quot;})
	public List&amp;lt;TreeNode&amp;gt; queryQuotaTreeData(QuotaManage quotaManage) {

		List&amp;lt;TreeNode&amp;gt; returnNodesList = new ArrayList&amp;lt;TreeNode&amp;gt;();

		List&amp;lt;TreeNode&amp;gt; nodeList = this.mapper.queryQuotaTreeData();

		returnNodesList = treeUtils.getParentList(nodeList);

		log.info(nodeList.size()+&amp;quot;&amp;quot;);

		return returnNodesList;
}

控制台截图拼接的get方法名称和获取的字段值
Redis的截图


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://shingmoyeung.coding.me/post/shou-xie-redis-cacheable-zhu-jie-can-shu-java-dui-xiang-zuo-wei-key-zhi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://shingmoyeung.coding.me/post/shou-xie-redis-cacheable-zhu-jie-zhi-chi-guo-qi-shi-jian-she-zhi">
                        手写Redis @Cacheable注解 支持过期时间设置
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-09-07 20:13</time>
                    
                        <a href="https://shingmoyeung.coding.me/tag/dai-ma-na-xie-shi-er" class="post-tag i-tag
                            i-tag-other_4">
            #代码那些事儿
        </a>
                        
                        <a href="https://shingmoyeung.coding.me/tag/redis" class="post-tag i-tag
                            i-tag-warning">
            #Redis
        </a>
                        
                        <a href="https://shingmoyeung.coding.me/tag/BJd4x8aTJ" class="post-tag i-tag
                            i-tag-">
            #2019-09
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            原理解释
友情链接  手写Redis @Cacheable注解参数java对象作为键值
@Cacheable注解作用，将带有该注解方法的返回值存放到redis的的中;
使用方法在方法上使用@Cacheable（键=“测试+＃P0 + P1＃...”）
表示键值为测试+方法第一个参数+方法第二个参数，值值为该方法的返回值。
以下源代码表示获取人员列表，Redis的中存放的关键值为&#39;领袖&#39;+ leaderGroupId + UUID + yearDetailId
    @Override
	@Cacheable(key=&amp;quot;&#39;leader&#39;+#p0+#p1+#p2&amp;quot;,value=&amp;quot;leader&amp;quot;)
	public List&amp;lt;Leader&amp;gt; listLeaders(String leaderGroupId, String uuid, String yearDetailId) {
		return sysIndexMapper.listLeaders(leaderGroupId, uuid, yearDetailId);
	}

等同于
    @Override
	public List&amp;lt;Leader&amp;gt; listLeaders(String leaderGroupId, String uuid, String yearDetailId) {
		String key = &amp;quot;leader&amp;quot; + leaderGroupId + uuid + yearDetailId;
		// 判断缓存是否存在redis中
		boolean hasKey = redisUtil.hasKey(key);
		if (hasKey) {
            //如果存在 返还redis中的值
			Object leadersList = redisUtil.get(key);
			return (List&amp;lt;Leader&amp;gt;) leadersList;
		} else {
			List&amp;lt;Leader&amp;gt; leadersQuotaDetailList = sysIndexMapper.listLeaders(leaderGroupId, uuid, yearDetailId);
            //将查询结果存放在redis中
			redisUtil.set(key, leadersQuotaDetailList);
			return leadersQuotaDetailList;
		}
	}
    ```
说白了就是在原方法的前面判断的关键值是否存在的Redis的中，如果存在就取内存中的值，如果不存在就查询数据库，将查询结果存放在Redis的的中。

#### 实现方法
使用代理模式，在方法执行前和执行后可以添加其他处理程序，本文采用springAOP +注解方式。
集成Redis，封装Redis工具类
原版本不支持关键过期时间设置，本文将实现
源代码
缓存配置类RedisConfig
```java
    package com.huajie.config;

    import org.springframework.beans.factory.annotation.Value;

    import org.springframework.cache.CacheManager;

    import org.springframework.cache.annotation.CachingConfigurerSupport;

    import org.springframework.cache.annotation.EnableCaching;

    import org.springframework.cache.interceptor.KeyGenerator;

    import org.springframework.context.annotation.Bean;

    import org.springframework.context.annotation.Configuration;

    import org.springframework.data.redis.cache.RedisCacheManager;

    import org.springframework.data.redis.connection.RedisConnectionFactory;

    import org.springframework.data.redis.core.RedisTemplate;

    import org.springframework.data.redis.core.StringRedisTemplate;

    import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;

    import org.springframework.data.redis.serializer.StringRedisSerializer;

    import com.fasterxml.jackson.annotation.JsonAutoDetect;

    import com.fasterxml.jackson.annotation.PropertyAccessor;

    import com.fasterxml.jackson.databind.ObjectMapper;

    

    /**

    * Redis缓存配置类

    */

    @Configuration

    @EnableCaching

    public class RedisConfig extends CachingConfigurerSupport {

 

	@Value(&amp;quot;${spring.redis.host}&amp;quot;)

	private String host;

	@Value(&amp;quot;${spring.redis.port}&amp;quot;)

	private int port;

	@Value(&amp;quot;${spring.redis.timeout}&amp;quot;)

	private int timeout;

 

	// 自定义缓存key生成策略

	@Bean

	public KeyGenerator keyGenerator() {

		return new KeyGenerator() {

			@Override

			public Object generate(Object target, java.lang.reflect.Method method, Object... params) {

				StringBuffer sb = new StringBuffer();

				sb.append(target.getClass().getName());

				sb.append(method.getName());

				for (Object obj : params) {

					sb.append(obj.toString());

				}

				return sb.toString();

			}

		};

	}

 

	// 缓存管理器

	@Bean

	public CacheManager cacheManager(@SuppressWarnings(&amp;quot;rawtypes&amp;quot;) RedisTemplate redisTemplate) {

		RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);

		// 设置缓存过期时间

		cacheManager.setDefaultExpiration(10000);

		return cacheManager;

	}

 

	@Bean

	public RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate(RedisConnectionFactory factory) {

		RedisTemplate&amp;lt;String, Object&amp;gt; template = new RedisTemplate&amp;lt;String, Object&amp;gt;();

		template.setConnectionFactory(factory);

		Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

		ObjectMapper om = new ObjectMapper();

		om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);

		om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);

		jackson2JsonRedisSerializer.setObjectMapper(om);

		StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

		// key采用String的序列化方式

		template.setKeySerializer(stringRedisSerializer);

		// hash的key也采用String的序列化方式

		template.setHashKeySerializer(stringRedisSerializer);

		// value序列化方式采用jackson

		template.setValueSerializer(jackson2JsonRedisSerializer);

		// hash的value序列化方式采用jackson

		template.setHashValueSerializer(jackson2JsonRedisSerializer);

		template.afterPropertiesSet();

		return template;

	}

 
	private void setSerializer(StringRedisTemplate template) {

		@SuppressWarnings({ &amp;quot;rawtypes&amp;quot;, &amp;quot;unchecked&amp;quot; })

		Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

		ObjectMapper om = new ObjectMapper();

		om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);

		om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);

		jackson2JsonRedisSerializer.setObjectMapper(om);

		template.setValueSerializer(jackson2JsonRedisSerializer);

	}
}

Redis的依赖引入，配置文件，工具类RedisUtil，网上几个版本都类似，本文参考以下版本传送门
https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html
准备工作做好之后开始正式编写注解@Cacheable nextkey（）用做二级缓存本文中不会用到
nextKey用法详情&amp;gt; 设计模式（实战） - 责任链模式 &amp;lt;
创建的Java的注解@ExtCacheable
    package com.huajie.annotation;

    import java.lang.annotation.ElementType;

    import java.lang.annotation.Retention;

    import java.lang.annotation.RetentionPolicy;

    import java.lang.annotation.Target;

    
    @Target({ ElementType.METHOD })
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ExtCacheable {

	String key() default &amp;quot;&amp;quot;;

	String nextKey() default &amp;quot;&amp;quot;;

	int expireTime() default 1800;//30分钟

}

SpringAop切面CacheableAspect
    package com.huajie.aspect;

    import java.lang.reflect.Method;

    import java.util.ArrayList;

    import java.util.List;

    import org.aspectj.lang.ProceedingJoinPoint;

    import org.aspectj.lang.annotation.Around;

    import org.aspectj.lang.annotation.Aspect;

    import org.aspectj.lang.annotation.Pointcut;

    import org.aspectj.lang.reflect.MethodSignature;

    import org.springframework.beans.factory.annotation.Autowired;

    import org.springframework.stereotype.Component;

    import com.huajie.annotation.ExtCacheable;

    import com.huajie.utils.RedisUtil;

    

    /**

     * redis缓存处理

     * 不适用与内部方法调用(this.)或者private

    */

    @Component

    @Aspect

    public class CacheableAspect {

	

	@Autowired

	private RedisUtil redisUtil;

 

	@Pointcut(&amp;quot;@annotation(com.huajie.annotation.ExtCacheable)&amp;quot;)

	public void annotationPointcut() {

	}

 

	@Around(&amp;quot;annotationPointcut()&amp;quot;)

	public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {

		// 获得当前访问的class

		Class&amp;lt;?&amp;gt; className = joinPoint.getTarget().getClass();

		// 获得访问的方法名

		String methodName = joinPoint.getSignature().getName();

		// 得到方法的参数的类型

		Class&amp;lt;?&amp;gt;[] argClass = ((MethodSignature) joinPoint.getSignature()).getParameterTypes();

		Object[] args = joinPoint.getArgs();

		String key = &amp;quot;&amp;quot;;

		int expireTime = 1800;

		try {

			// 得到访问的方法对象

			Method method = className.getMethod(methodName, argClass);

			method.setAccessible(true);

			// 判断是否存在@ExtCacheable注解

			if (method.isAnnotationPresent(ExtCacheable.class)) {

				ExtCacheable annotation = method.getAnnotation(ExtCacheable.class);

				key = getRedisKey(args,annotation);

				expireTime = getExpireTime(annotation);

			}

		} catch (Exception e) {

			throw new RuntimeException(&amp;quot;redis缓存注解参数异常&amp;quot;, e);

		}

		// 获取缓存是否存在

		boolean hasKey = redisUtil.hasKey(key);

		if (hasKey) {

			return redisUtil.get(key);

		} else {

                         //执行原方法（java反射执行method获取结果）

			Object res = joinPoint.proceed();

                         //设置缓存

			redisUtil.set(key, res);

                         //设置过期时间

			redisUtil.expire(key, expireTime);

			return res;

		}

	}

	

	private int getExpireTime(ExtCacheable annotation) {

		return annotation.expireTime();

	}

 

	private String getRedisKey(Object[] args,ExtCacheable annotation) {

		String primalKey = annotation.key();

		//获取#p0...集合

		List&amp;lt;String&amp;gt; keyList = getKeyParsList(primalKey);

		for (String keyName : keyList) {

			int keyIndex = Integer.parseInt(keyName.toLowerCase().replace(&amp;quot;#p&amp;quot;, &amp;quot;&amp;quot;));

			Object parValue = args[keyIndex];

			primalKey = primalKey.replace(keyName, String.valueOf(parValue));

		}

		return primalKey.replace(&amp;quot;+&amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot;&#39;&amp;quot;,&amp;quot;&amp;quot;);

	}

 

	// 获取key中#p0中的参数名称

	private static List&amp;lt;String&amp;gt; getKeyParsList(String key) {

		List&amp;lt;String&amp;gt; ListPar = new ArrayList&amp;lt;String&amp;gt;();

		if (key.indexOf(&amp;quot;#&amp;quot;) &amp;gt;= 0) {

			int plusIndex = key.substring(key.indexOf(&amp;quot;#&amp;quot;)).indexOf(&amp;quot;+&amp;quot;);

			int indexNext = 0;

			String parName = &amp;quot;&amp;quot;;

			int indexPre = key.indexOf(&amp;quot;#&amp;quot;);

			if(plusIndex&amp;gt;0){

				indexNext = key.indexOf(&amp;quot;#&amp;quot;) + key.substring(key.indexOf(&amp;quot;#&amp;quot;)).indexOf(&amp;quot;+&amp;quot;);

				parName = key.substring(indexPre, indexNext);

			}else{

				parName = key.substring(indexPre);

			}

			ListPar.add(parName.trim());

			key = key.substring(indexNext + 1);

			if (key.indexOf(&amp;quot;#&amp;quot;) &amp;gt;= 0) {

				ListPar.addAll(getKeyParsList(key));

			}

		}

		return ListPar;

	}
}

业务模块使用方法
    @Override
	@ExtCacheable(key = &amp;quot;Leaders+#p0+#p1+#p2&amp;quot;)
	// 手机端获取领导人员列表
	public List&amp;lt;Leader&amp;gt; listLeaders(String leaderGroupId, String uuid, String yearDetailId) {
		List&amp;lt;Leader&amp;gt; leadersQuotaDetailList = sysIndexMapper.listLeaders(leaderGroupId, uuid, yearDetailId);
		return leadersQuotaDetailList;
}

业务模块过期时间使用方法，5分钟过期
    @Override
	@ExtCacheable(key = &amp;quot;mobileCacheFlag&amp;quot;, expireTime = 60 * 5)
	public int cacheFlag() {
		int mobileCacheFlag = 1;
		mobileCacheFlag = sysIndexMapper.cacheFlag();
		return mobileCacheFlag;

}

Redis的的截图


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://shingmoyeung.coding.me/post/shou-xie-redis-cacheable-zhu-jie-zhi-chi-guo-qi-shi-jian-she-zhi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://shingmoyeung.coding.me/post/bi-ji-qian-yi">
                        笔记迁移......
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-02-20 15:46</time>
                    
                        <a href="https://shingmoyeung.coding.me/tag/V4bUS6WRg" class="post-tag i-tag
                            i-tag-">
            #杂记
        </a>
                        
                        <a href="https://shingmoyeung.coding.me/tag/BJd4x8aTJ" class="post-tag i-tag
                            i-tag-success">
            #2019-09
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://shingmoyeung.coding.me/post/bi-ji-qian-yi" class="post-feature-image" style="background-image:url(https://shingmoyeung.coding.me/post-images/bi-ji-qian-yi.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
&amp;emsp;&amp;emsp;从大学毕业到现在，零零散散的保留着工作笔记的习惯。虽多数是借鉴别人，目前累计下来也有两百余篇，从一开始的文档记录到单机笔记软件，又从软件到云笔记，来来回回折腾几次后，终于找到这种既能满足自己平时工作记录，又能起到分享予人，关键还免费的服务来统一管理这些琐碎记录。
&amp;emsp;&amp;emsp;由于一些原因吧，这些笔记中有的有转发声明，有的没有，有的已经过时，有的可能不对。总之，看到的同学，如有伤及请及时联系，本人将配合予以更正。
&amp;emsp;&amp;emsp;这样，对外的同学既是声明，也算对自己多年来有个总结。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://shingmoyeung.coding.me/post/bi-ji-qian-yi">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://shingmoyeung.coding.me/images/avatar.png?v=1569673038247)">
        </div>
        <h1 class="id_card-title">
            代码人生
        </h1>
        <h2 class="id_card-description">
            代码 人生 感悟 分享
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://codingforever.cn" target="_blank">The Code of Life</a> | 
  <a class="rss" href="https://shingmoyeung.coding.me/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>